# NUPACK class
# This program is part of the TUPack software package and makes use of NuPack 3.0. NuPack can be found on <www.nupack.org>
# This class creates an object that is able to call NuPack 3.0 binary complexes and to read and return the NuPack output files.
# For more info about the program, please read the user manual.
#
# written by Sander Rodenburg
# Eindhoven University of Technology
# March 2012

# importing libraries
#import Bio
import os
import subprocess as sub
import time
import random
import sys
sys.path.append('/home/s120315/lib64/python2.5/site-packages')
import tkFileDialog
from Tkinter import *

class NUPACK:

  def __init__(self, prefix, paramFile=None, silent=False, NPH=None, T=None, degenerate=None, material=None, dangles=None,
               sodium=None, magnesium=None, ordered=None, mfe=None, quiet=None, timeonly=None, pairs=None, cutoff=None, sort=None):

    # runCount holds the number of NuPack runs
    self.runCount = 0

    # are the parameters loaded?
    self.paramLoaded = False
    self.silent = silent
    self.prefix = prefix
    
    # initialize empty NuPack parameter variables
    self.NuPackHome = NPH
    self.T = T
    self.degenerate = degenerate
    self.material = material
    self.dangles = dangles
    self.sodium = sodium
    self.magnesium = magnesium
    self.ordered = ordered
    self.mfe = mfe
    self.quiet = quiet
    self.timeonly = timeonly
    self.pairs = pairs
    self.cutoff = cutoff
    self.sort = sort

    self.paramFile = paramFile

  # function for setting the NuPack 3.0 runtime environment
  def _setEnv(self):

    # set NuPack environment
    if not self.silent:
      print "Setting NuPack home directory...\n"
    
    # define the NuPack environment
    os.putenv("NUPACKHOME", self.NuPackHome)

  # read output from files generated by complexes
  def readLastOutput(self):
    # create empty lists
    sequences = []        # contains the sequences
    sequenceIDs = []      # contains the sequence ID's
    complexes = []        # contains the duplex information
    deltaG = []           # contains the free energy
    cx = []               # contains a duplex
    #mdG = []       # contains the predicted structure
    cxData = []           # contains complex information
    
    temp = []

    # if a mfe structures file should be generated, enable reading
    if self.ordered == True and self.mfe == True:
      readStructures = True
    else:
      readStructures = False

    # opening files
    inFile = open(self.prefix+".in", "r")
    cxFile = open(self.prefix+".cx", "r")
    ocx_mfeFile = open(self.prefix+".ocx-mfe", "r")

    if not self.silent:  
      print "Reading results...\n"

    # read file and strip line of irrelevant symbols
    i = 0
    for line in inFile:
      line = line.strip("\n")

      # if the line is a digit, meaning it's no comment line, extract sequences from it and give them an ID
      if line[0].isdigit():
        pass
      else:
        i += 1
        sequences += [str(line)]
        sequenceIDs += [i]

    # close the file
    inFile.close()

    # read complex file
    if not self.silent:
      print "Reading complex combinations...\n"
    for line in cxFile:
      element = []

      # if the line is no comment line
      if line.count("%") == 0:

        # string operations
        line = line.strip("\n").split("\t")

        # extract delta G from the line
        deltaG += [line[len(line)-1]]
        line = line[1:len(line)-1]

        # for each column, convert value to an integer
        cnt = 0
        for col in line:
          col = int(col)
          
          # if the value is equal to or more than 1, corresponding sequence has a role in a complex
          if col >= 1:

            # add complex sequences to element list
            for val in range(col):
              element += [sequenceIDs[cnt]]

          cnt += 1

        # add element list to complexes list
        complexes += [element]

    # close file
    cxFile.close()

    # if the ocx file should be read
    """if readStructures:
      # read ocx-mfe file
      if not self.silent:
        print "Reading complex structures and free energies...\n"
      cnt = 0
      cnt2= 0
      for line in ocx_mfeFile:
        if cnt2<7:
          # Number of the line of the current complex
          cnt+=1
          if line.count('%') == 0:
            line = line.strip("\n")

            # if counter is equal to 4, add structure to structures list
            if cnt==2:
              cnt2+=1
              mdG += [line]
          else:
            # If we move to the next complex, separated by %, we set the counter to 0, since we only need the third line of each complex
            cnt=0"""
    """# if there's a line full of '%' symbols, if reading is already enabled, disable it. If the reading is disabled, start reading by enabling it.
        if line.count("%") > 1:
          if readComplex:
            readComplex = False
          else:
            readComplex = True
            cnt = 0"""
        

    # screen output
    if not self.silent:
      # print output headers and read complex list
      if readStructures:
        print "Strand 1:\tStrand 2:\tFree Energy:\t\tStructure:\n"
      else:
        print "Strand 1:\tStrand 2:\tFree Energy:\n"
    x=0

    for cmplx in complexes:
      output = []

      # get delta G, strands and structures from previous lists
      for seq in cmplx:
        output += [seq]
        
      output += [deltaG[x]]

      x+=1  

      # add them all to one list
      cxData += [output]

      if not self.silent:
        
        # print output data
        if readStructures:
          if len(output) == 4:
            print "sequence", output[0], "\tsequence", output[1], "\t", output[2], "\t", output[3]
          elif len(output) == 3:
            print "sequence", output[0], "\t\t\t", output[1], "\t", output[2]
        else:
          if len(output) == 3:
            print "sequence", output[0], "\tsequence", output[1], "\t", output[2]
          elif len(output) == 2:
            print "sequence", output[0], "\t\t\t", output[1]
        print "\n"

    # close file
    ocx_mfeFile.close()
    # return
    return cxData

  # read concentrations
  def readConcOutput(self):
    complexindices = []
    concentrations = []
    energies = []
    multiplicity = []
    
    concFile = open(self.prefix+".eq", "r")
    # Array for species already visited (we only want one entry per species, but NUPACK can report more)
    SpeciesIndices=[]
    
    for line in concFile:
      if line.count("%") == 0:
        # Last line entry is empty string so do not use
        line = line.strip("\n").split("\t")
        # Should we be dealing with small concentrations (smaller than a pM) and a species already visited, terminate
        if float(line[len(line)-2])>=1e-13 and float(line[0]) not in SpeciesIndices:
          # Add current species to visited species
          SpeciesIndices.append(float(line[0]))
          # Run through the file again and find all permutations, then add the concentrations of the permutations to the species
          concFile2 = open(self.prefix+".eq", "r")
          concIntermediate=0
          for line2 in concFile2:
            line2 = line2.strip("\n").split("\t")
            if line2[0]==line[0] and line2[1]!=line[1]:
              concIntermediate=concIntermediate+float(line2[len(line2)-2])
          concFile2.close()
          counter = 0
          z=[]
          y=[]
          for col in range(2,len(line)-3):
            counter += 1
            if int(line[col]) >= 1:
              z += [counter]
              y += [int(line[col])]
          complexindices += [z]
          multiplicity+=[y]
          concentrations += [float(line[len(line)-2])+concIntermediate]
          energies += [float(line[len(line)-3])]
        else:
          break
    concFile.close()
    return complexindices, multiplicity, concentrations, energies
    

  # calls complexes with the given parameters
  def runComplexes(self):

    # if the parameters are not loaded, load them
    if not self.paramLoaded:
      self._getParameters()
      self._setEnv()
      self.paramLoaded = True

    # determine command from parameter values
    cmd = self.NuPackHome+"/bin/complexes"
    if self.T != None: cmd += " -T " +str(self.T)
    if self.material != None: cmd += " -material " +str(self.material)
    if self.ordered == True: cmd += " -ordered"
    if self.pairs == True: cmd += " -pairs"
    if self.mfe == True: cmd += " -mfe"
    if self.degenerate == True: cmd += " -degenerate"
    if self.dangles != None: cmd += " -dangles " +str(self.dangles)
    if self.timeonly == True: cmd += " -timeonly"
    if self.quiet == True: cmd += " -quiet"
    if self.cutoff != None: cmd += " -cutoff " +str(self.cutoff)
    if self.sodium != None: cmd += " -sodium " +str(self.sodium)
    if self.magnesium != None: cmd += " -magnesium " +str(self.magnesium)
    cmd += " " +self.prefix

    if not self.silent:
      print "Command:"
      print cmd + "\n"

    os.chdir(os.path.dirname(self.prefix))
    
    # call command in shell process 
    proc = sub.Popen(cmd, stdout=sub.PIPE, shell=True)

    # wait for the process to run
    while proc.poll() is None:
      proc.communicate()
      try:
        proc.wait()
        time.sleep(0.001)
      except:
        break

    self.runCount += 1

  # reads and implements the parameters from parameters.txt       
  def _getParameters(self):

    try:
      paramFile = open(self.paramFile, "r")
    except (IOError, TypeError):
      paramFile = self._chooseFile("Select parameter file")

    if paramFile == None:
      sys.exit("Parameter file missing")

    # get parameters
    if not self.silent:
      print "Reading parameters...\n"      

    # read parameter file
    for line in paramFile:

      # filter comment lines
      if not line.startswith("#"):

        # determine parameters and values
        try:
          par = str(line.split(" = ")[0])
          arg = str(line.split(" = ")[1]).strip("\n")
          
          # read string parameters
          if par == "home":
            if self.NuPackHome==None:
              self.NuPackHome = arg

          elif par == "material":
            if self.material==None:
              if arg == "rna" or arg == "rna1995":
                self.material = "rna"
              elif arg == "dna" or arg == "dna1998":
                self.material = "dna"
              elif arg == "rna1999":
                self.material = "rna1999"

          elif par == "dangles":
            if self.dangles==None:
              if arg.lower() == "all":
                self.dangles = "all"
              elif arg.lower() == "some":
                self.dangles = "some"
              elif arg.lower() == "none":
                self.dangles = "none"

          # read and convert nummeric parameters
          elif par == "T":
            if self.T==None:
              self.T = float(arg)
          elif par == "sodium":
            if self.sodium==None:
              self.sodium = float(arg)
          elif par == "magnesium":
            if self.magnesium==None:
              self.magnesium = float(arg)
          
          # read  and convert boolean parameters
          elif par == "timeonly":
            if self.timeonly==None:
              self.timeonly = self._strToBool(par, arg)
          elif par == "quiet":
            if self.quiet==None:
              self.quiet = self._strToBool(par, arg)
          elif par == "mfe":
            if self.mfe==None:
              self.mfe = self._strToBool(par, arg)
          elif par == "pairs":
            if self.pairs==None:
              self.pairs = self._strToBool(par, arg)
          elif par == "ordered":
            if self.ordered==None:
              self.ordered = self._strToBool(par, arg)
          elif par == "degenerate":
            if self.degenerate==None:
              self.degenerate = self._strToBool(par, arg)

          # raise an error in all other cases
          else: raise IndexError

          if not self.silent:
            # print the parameters
            print par +" = "+ arg       

        except IndexError:
          print "Unexpected line: "+str(line)

    # close parameter file
    paramFile.close()

  # converts string to boolean
  def _strToBool(self, par, arg):
    if arg.lower().capitalize() == "True":
      ret = True
    elif arg.lower().capitalize() == "False":
      ret = False
    else:
      raise ValueError("Unexpected input in parameter file: " , par +"\t"+ arg)

    return ret  

  # toggle silent mode
  def setSilent(self, value):
    if value.__class__.__name__ != "bool":
      raise ValueError("Value should be a boolean.")
    self.silent = value

  # Function to evaluate the concentrations of all species in steady state.
  def runConcentrations(self):

    # if the parameters are not loaded, load them
    if not self.paramLoaded:
      self._getParameters()
      self._setEnv()
      self.paramLoaded = True

    # determine command from parameter values
    cmd = self.NuPackHome +"/bin/concentrations"
    if self.ordered == True: cmd += " -ordered"
    if self.pairs == True: cmd += " -pairs"
    if self.sort != None: cmd += " -sort "+str(self.sort)
    if self.quiet == True: cmd += " -quiet"
    cmd += " " +self.prefix

    if not self.silent:
      print "Command:"
      print cmd + "\n"
      
    os.chdir(os.path.dirname(self.prefix))
    
    # call command in shell process 
    proc = sub.Popen(cmd, stdout=sub.PIPE, shell=True)

    # wait for the process to run
    while proc.poll() is None:
      proc.communicate()
      try:
        proc.wait()
        time.sleep(0.001)
      except:
        break


  # function for popping up a file chooser
  def _chooseFile(self, Title):

    # initialize the Tk object
    root = Tk()

    # withdraw the main window
    root.withdraw()

    # open file chooser on the current directory
    File = tkFileDialog.askopenfile(parent=root, mode='r', title=Title, initialdir=os.getcwd())

    # exit the windows
    root.quit()

    # return files
    return File
